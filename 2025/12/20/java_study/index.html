<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java基础到精通 | Welcome to my blog</title><meta name="author" content="bluetea"><meta name="copyright" content="bluetea"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="c语言的一些系统性的知识">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础到精通">
<meta property="og:url" content="https://17bluetea.github.io/2025/12/20/java_study/index.html">
<meta property="og:site_name" content="Welcome to my blog">
<meta property="og:description" content="c语言的一些系统性的知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://17bluetea.github.io/images/qita/java.jpg">
<meta property="article:published_time" content="2025-12-20T00:00:00.000Z">
<meta property="article:modified_time" content="2025-11-05T00:38:42.850Z">
<meta property="article:author" content="bluetea">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://17bluetea.github.io/images/qita/java.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "java基础到精通",
  "url": "https://17bluetea.github.io/2025/12/20/java_study/",
  "image": "https://17bluetea.github.io/images/qita/java.jpg",
  "datePublished": "2025-12-20T00:00:00.000Z",
  "dateModified": "2025-11-05T00:38:42.850Z",
  "author": [
    {
      "@type": "Person",
      "name": "bluetea",
      "url": "https://17bluetea.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://17bluetea.github.io/2025/12/20/java_study/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础到精通',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div id="web_bg" style="background-image: url(/images/home/first.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/home/first.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Welcome to my blog</span></a><a class="nav-page-title" href="/"><span class="site-name">java基础到精通</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">java基础到精通</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-20T00:00:00.000Z" title="发表于 2025-12-20 08:00:00">2025-12-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-05T00:38:42.850Z" title="更新于 2025-11-05 08:38:42">2025-11-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/computer-language/">computer language</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/computer-language/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="java-study"><a href="#java-study" class="headerlink" title="java_study"></a>java_study</h1><h2 id="1-Java-中的注释"><a href="#1-Java-中的注释" class="headerlink" title="1. Java 中的注释"></a>1. Java 中的注释</h2><ul>
<li>单行注释：<code>// 注释信息</code></li>
<li>多行注释：<code>/* 注释信息 */</code></li>
<li>文档注释：<code>/** 注释信息 */</code></li>
</ul>
<p>基础语法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="comment">// 第一行是类的定义，HelloWorld 是类名，通常与文件名一致</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// main 方法是程序的入口，这是固定写法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出语句：会把小括号里的内容打印到控制台</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JVM:  就是java的虚拟机</span><br><span class="line"><span class="keyword">public</span>:   被JVM调用，访问权限足够大</span><br><span class="line"><span class="keyword">static</span>:   被JVM调用，不用创建对象，直接类名访问</span><br><span class="line">          因为mian方法是静态的，所以测试类中其他方法也需要是静态的</span><br><span class="line"><span class="keyword">void</span>:     被JVM调用，不需要给JVM返回值</span><br><span class="line">main:     一个通用的名称，虽然不是关键字，但是被JVM识别</span><br><span class="line">String[] args:  以前用于接收键盘录入数据，现在没用</span><br></pre></td></tr></table></figure>

<h2 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2. 关键字"></a>2. 关键字</h2><p>class：用于定义一个类。类是 Java 的基本组织单元，所有代码都要写在类的大括号中。</p>
<h2 id="3-字面量"><a href="#3-字面量" class="headerlink" title="3. 字面量"></a>3. 字面量</h2><table>
<thead>
<tr>
<th>字面量类型</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>不带小数点的数字</td>
<td>666，-88</td>
</tr>
<tr>
<td>小数类型</td>
<td>带小数点的数字</td>
<td>13.14，-5.21</td>
</tr>
<tr>
<td>字符串类型</td>
<td>用双引号括起来的内容</td>
<td>“Hello World”，”我是蓝茶”</td>
</tr>
<tr>
<td>字符类型</td>
<td>用单引号括起来的单个字符</td>
<td>‘A’  ‘O’  ‘我’</td>
</tr>
<tr>
<td>布尔类型</td>
<td>表示真假</td>
<td>true，false</td>
</tr>
<tr>
<td>空引用</td>
<td>特殊的空值</td>
<td>null</td>
</tr>
</tbody></table>
<p><strong>特殊字符</strong></p>
<ul>
<li><code>\t</code>：制表符。在打印时把前面字符串的长度补齐到 8 的整数倍，最少补 1 个空格，最多补 8 个空格（IDEA 中通常等效为 4）。</li>
</ul>
<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><p>变量的定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据类型  变量名 = 数据值；</span><br></pre></td></tr></table></figure>

<ul>
<li>数据类型：存储的数据类别与范围</li>
<li>变量名：给存储空间起的名字</li>
<li>数据值：存入空间的具体值</li>
</ul>
<h2 id="5-数据类型"><a href="#5-数据类型" class="headerlink" title="5. 数据类型"></a>5. 数据类型</h2><p>Java 的数据类型分为：基本数据类型、引用数据类型。</p>
<p><strong>基本数据类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类别   关键字   取值范围（近似）</span><br><span class="line">byte            -128 ~ 127</span><br><span class="line">short           -32768 ~ 32767</span><br><span class="line">int(默认)       -2147483648 ~ 2147483647</span><br><span class="line">long            -9223372036854775808 ~ 9223372036854775807</span><br><span class="line">float           ~1.4E-45 ~ 3.4E38（单精度）</span><br><span class="line">double(默认)    ~4.9E-324 ~ 1.8E308（双精度）</span><br><span class="line">char            0 ~ 65535（无符号）</span><br><span class="line">boolean         true / false</span><br></pre></td></tr></table></figure>

<p>数值类型大致范围比较：<code>double &gt; float &gt; long &gt; int &gt; short &gt; byte</code></p>
<p><strong>引用数据类型</strong></p>
<ul>
<li>类、接口、数组、枚举、注解、记录等</li>
</ul>
<h2 id="6-标识符"><a href="#6-标识符" class="headerlink" title="6. 标识符"></a>6. 标识符</h2><p>标识符是给类、方法、变量等起的名字。</p>
<p>命名规则（硬性要求）：</p>
<ol>
<li>由字母、数字、下划线 <code>_</code>、美元符号 <code>$</code> 组成</li>
<li>不能以数字开头</li>
<li>不能是关键字</li>
<li>区分大小写</li>
</ol>
<h2 id="7-键盘录入（Scanner）"><a href="#7-键盘录入（Scanner）" class="headerlink" title="7. 键盘录入（Scanner）"></a>7. 键盘录入（Scanner）</h2><p>Scanner 可以接收键盘输入：</p>
<ul>
<li>导包（必须写在类定义上方）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>([System.in](http:<span class="comment">//System.in)); // 只有 sc 是变量名可变</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接收数据：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 只有 i 是变量名可变</span></span><br></pre></td></tr></table></figure>

<h2 id="8-运算符"><a href="#8-运算符" class="headerlink" title="8. 运算符"></a>8. 运算符</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>注意事项：</p>
<p>&#x2F; 和 % 的区别：两个数据做除法，&#x2F; 取结果的商， % 取结果的余数。</p>
<p>整数操作只能得到整数，要想得到小数，必须有浮点数参与运算</p>
<p><strong>隐式转换的两种提升规则</strong></p>
<pre><code>（1）取值范围小，和取值范围大的进行运算，小的会先提升为大的，再进行运算

（2）byte short char  三种类型的数据在运算的时候，都会直接提升为int，然后再进行运算
</code></pre>
<p>整数和小数取值范围大小关系：double&gt;float&gt;long&gt;int&gt;short&gt;byte</p>
<p><strong>强制转换（c语言中的强制类型转换）</strong></p>
<p>如果把一个取值范围大的数值，赋值给取值范围小的变量，是不允许直接赋值的，如果一定要这么做就需要加入强制转换</p>
<pre><code>   格式：目标数据类型 变量名=（目标数据类型）被强转的数据
</code></pre>
<p><strong>个人总结：如果代码中有“”（单引号）代表的是字符串等，但是如果是’’（单引号）那么单引号中的数据将会以ASCLL值来输出（与c语言对应）</strong></p>
<h3 id="（2）自增自减运算符"><a href="#（2）自增自减运算符" class="headerlink" title="（2）自增自减运算符"></a>（2）自增自减运算符</h3><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>++</td>
<td>加</td>
<td>变量的值加1</td>
</tr>
<tr>
<td>- -</td>
<td>减</td>
<td>变量的值减1</td>
</tr>
</tbody></table>
<p>注意事项：</p>
<p>++和- -既可以放在变量的前边，也可以放在变量的后面</p>
<p>如果++或- -在后面那么是<strong>先用后加</strong></p>
<p>如果++或- -在前面那么是<strong>先加后用</strong></p>
<h3 id="（3）赋值运算符"><a href="#（3）赋值运算符" class="headerlink" title="（3）赋值运算符"></a>（3）赋值运算符</h3><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>赋值</td>
<td>int a&#x3D;10，将10赋值给变量a</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加后赋值</td>
<td>a+&#x3D;b,将a+b的值给a</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减后赋值</td>
<td>a-&#x3D;b，将a-b的值给a</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘后赋值</td>
<td>a*&#x3D;b，将a×b的值给a</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除后赋值</td>
<td>a&#x2F;&#x3D;b，将a÷b的商给a</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>取余后赋值</td>
<td>a%&#x3D;b，将a÷b的余数给a</td>
</tr>
</tbody></table>
<p>细节：+&#x3D;，-&#x3D;，&#x2F;&#x3D;，%&#x3D;底层都隐藏了一个强制类型转换</p>
<h3 id="（4）（关系运算符-比较运算符）的关系"><a href="#（4）（关系运算符-比较运算符）的关系" class="headerlink" title="（4）（关系运算符&#x2F;比较运算符）的关系"></a>（4）（关系运算符&#x2F;比较运算符）的关系</h3><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>a&#x3D;&#x3D;b，判断a和b的值是否相等，成立为true，不成立false</td>
</tr>
<tr>
<td>！&#x3D;</td>
<td>a!&#x3D;b，判断a和b的值是否不相等，成立为true，不成立false</td>
</tr>
<tr>
<td>&gt;</td>
<td>a&gt;b,判断a是否大于b，成立为true，不成立为false</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>a&gt;&#x3D;b，判断a是否大于等于b，成立为true，不成立为false</td>
</tr>
<tr>
<td>&lt;</td>
<td>a&lt;b，判断a是否小于b，成立为true，不成立为false</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>a&lt;&#x3D;b，判断a是否小于等于b，成立为true，不成立为false</td>
</tr>
</tbody></table>
<h3 id="（5）逻辑运算符"><a href="#（5）逻辑运算符" class="headerlink" title="（5）逻辑运算符"></a>（5）逻辑运算符</h3><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>逻辑与（且）</td>
<td>并且，两边都为真，结果才是真</td>
</tr>
<tr>
<td></td>
<td></td>
<td>逻辑或</td>
</tr>
<tr>
<td>^</td>
<td>逻辑异或</td>
<td>相同为false，不同为true</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非</td>
<td>取反</td>
</tr>
</tbody></table>
<p>短路逻辑运算符</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>短路与</td>
<td>结果和 &amp; 相同，但有短路效果</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>短路效果</strong>（Short-Circuit Evaluation）指的是逻辑运算符（<code>&amp;&amp;</code> 与 <code>||</code>）在计算表达式时，会根据第一个操作数的结果提前终止计算，无需执行第二个操作数的现象。</p>
<p>这种机制可以提高代码效率，还能避免不必要的错误（如空指针异常）</p>
<h3 id="（6）三元运算符"><a href="#（6）三元运算符" class="headerlink" title="（6）三元运算符"></a>（6）三元运算符</h3><p>三元运算符的定义： 需求：定义一个变量记录两个整数的较大值</p>
<p>格式：关系表达式 ? 表达式 : 表达式2；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">范例:求两个数的较大值</span><br><span class="line">   <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a &gt; b ? a : b;  <span class="comment">//把三元运算符的结果赋值给一个变量</span></span><br><span class="line">   System.out.println(a &gt; b ? a : b);   <span class="comment">//把三元运算符的结果直接打印</span></span><br><span class="line">   </span><br><span class="line">   计算规则</span><br><span class="line">      首先计算关系表达式的值</span><br><span class="line">      如果值为<span class="literal">true</span>，表达式<span class="number">1</span>的值就是运算结果</span><br><span class="line">      如果值为<span class="literal">false</span>，表达式<span class="number">2</span>的值就是运算结果</span><br></pre></td></tr></table></figure>

<h3 id="（7）运算符的优先级"><a href="#（7）运算符的优先级" class="headerlink" title="（7）运算符的优先级"></a>（7）运算符的优先级</h3><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>.  ( )   { }</td>
</tr>
<tr>
<td>2</td>
<td>!     -     ++     - -</td>
</tr>
<tr>
<td>3</td>
<td>*   &#x2F;   %</td>
</tr>
<tr>
<td>4</td>
<td>+   -</td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt;     &gt;&gt;    &gt;&gt;&gt;</td>
</tr>
<tr>
<td>6</td>
<td>&lt;  &lt;&#x3D;  &gt;  &gt;&#x3D;  instanceof</td>
</tr>
<tr>
<td>7</td>
<td>&#x3D;&#x3D;   !&#x3D;</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
</tr>
<tr>
<td>10</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>12</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>?  :</td>
</tr>
<tr>
<td>14</td>
<td>&#x3D;  +&#x3D;  -&#x3D;  *&#x3D;  &#x2F;&#x3D;  %&#x3D;  &amp;&#x3D;</td>
</tr>
</tbody></table>
<h2 id="9-流程控制语句"><a href="#9-流程控制语句" class="headerlink" title="9.流程控制语句"></a>9.流程控制语句</h2><h3 id="（1）顺序结构"><a href="#（1）顺序结构" class="headerlink" title="（1）顺序结构"></a>（1）顺序结构</h3><p>顺序结构语句是Java程序默认的执行流程，按照代码的先后顺序，从上到下一次执行</p>
<h3 id="（2）分支结构"><a href="#（2）分支结构" class="headerlink" title="（2）分支结构"></a>（2）分支结构</h3><p>[ 1 ] if语句</p>
<pre><code>   （1）if语句的第一种格式
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>（关系表达式）&#123;</span><br><span class="line">     语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code> if的注意点：

        1.大括号的开头可以另起一行书写，但是建议写第一行的末尾

        2.在语句体中，如果只有一句代码，大括号可以省略不写，个人建议

        大括号还是不要省略

         3.如果对一个布尔类型的变量进行判断，不i要用==号，直接把变量写在小括号

         即可                            

 执行流程：

        1.首先计算关系表达式的值

        2.如果关系表达式的值为true就执行语句体

        3.如果关系表达式的值为false就不执行语句体

        4.继续执行后面的其他语句
</code></pre>
<p>  （2）if语句的第二种格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>（关系表达式）&#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    语句体;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<pre><code>     执行流程：

              1.首先计算关系式的值

              2.如果关系表达式的值为true就执行语句体1

              3.如果关系式的值为false就执行语句体2

              4.继续执行后面的其他语句
</code></pre>
<p>（3）if语句的第三种格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式<span class="number">1</span>)&#123;</span><br><span class="line">     语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(关系表达式<span class="number">2</span>)&#123;</span><br><span class="line">     语句体;</span><br><span class="line">&#125;</span><br><span class="line">     ……</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">     语句体 n+<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<pre><code>     执行流程：

               1.首先计算关系表达式1的值

               2.如果为true就执行语句体1；如果为false就计算关系表达式2的值

               3.如果为true就执行语句体2；如果为false就计算关系表达式3的值

               4.  ……

               5.如果所以关系表达式结果都为false，就执行语句体n+1
</code></pre>
<p>   [2]  switch语句格式 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>;</span><br><span class="line">         语句体<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>;</span><br><span class="line">         语句体<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      ……</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">          语句体n+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式说明:</span></span><br><span class="line"><span class="comment">//1.表达式:（将要匹配的值）取值byte short int char。JDK5以后可以枚举,JDK7以后可以是String</span></span><br><span class="line"><span class="comment">//2.case:后面跟的是要和表达式进行比较的值（被匹配的值）</span></span><br><span class="line"><span class="comment">//3.break:表示中断，结束的意思，用来结束switch语句</span></span><br><span class="line"><span class="comment">//4.default:表达所有情况都不匹配的时候，就执行该处的内容，和if语句的else相似</span></span><br><span class="line"><span class="comment">//5.case后面的值只能是字面量，不能是变量</span></span><br><span class="line"><span class="comment">//6.case给出的值不允许重复</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>  执行流程：

         1.首先计算表达式的值

         2.依次和case后面的值进行比较，如果有对应的值，就会执行相应的语句，在                                               执行的过程中，遇到break就会结束

         3.如果所有的case后面的值和表达式的值都不匹配，就会执行default里面的语                                              句体，然后结束整个switch语句
</code></pre>
<p>   switch其他知识点：</p>
<pre><code>   1.default的位置和省略

       位置：default不一定是写在最下面的，我们可以写在任意位置，只不过习惯写在最下面

       省略：default可以省略，语法不会出问题，但是不建议省略

   2.case穿透

      就是语句体种没有写break导致的

      执行流程：

                      首先还是会拿着小括号中表达式的值跟下面每一个case进行匹配

                      如果匹配上了，就会执行对应的语句体，如果此时发现了break，那么结束整个switch

                      如果没有发现break，那么程序会继续执行下一个case的语句体，一直遇到break或者                              大括号为止

   3.switch新特性

      优化语句体和break
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">以前</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (number)&#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现在</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span> (number)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span> -&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>   4.switch和if第三种格式各自的使用场景

      if的第三种格式，一般用于对范围的判断

      switch：把有限个数据一一列举出来，让我们任选其一
</code></pre>
<h3 id="（3）循环结构"><a href="#（3）循环结构" class="headerlink" title="（3）循环结构"></a>（3）循环结构</h3><p> for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">10</span>;i++)&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程：</p>
<p>1.执行初始化语句</p>
<p>2.执行条件判断语句，看其结果是true还是false</p>
<pre><code>  如果是false，循环结束

  如果是true，执行循环体语句
</code></pre>
<p>3.执行条件控制语句</p>
<p>4.回到2继续执行条件判断语句</p>
<p>while循环的执行流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式:</span><br><span class="line">初始化语句</span><br><span class="line"><span class="keyword">while</span>(条件判断语句)&#123;</span><br><span class="line">     循环体语句;</span><br><span class="line">     条件控制语句;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">初始化语句只执行一次 判断语句为<span class="literal">true</span>，循环继续 判断语句为<span class="literal">false</span>，循环结束</span><br></pre></td></tr></table></figure>

<p>for和while的对比</p>
<p>相同点：运行规则都是一样的</p>
<p>for和while的区别：</p>
<p>for循环中，控制循环的变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了</p>
<p>while循环中，控制循环变量，对于while训话来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用</p>
<p>do……while循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式</span><br><span class="line">初始化语句</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"> 循环体语句</span><br><span class="line"> 条件控制语句</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断语句)</span><br><span class="line"></span><br><span class="line">选执行后判断</span><br></pre></td></tr></table></figure>

<h3 id="（4）高级循环"><a href="#（4）高级循环" class="headerlink" title="（4）高级循环"></a>（4）高级循环</h3><p>1.无限循环：循环一直停不下来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">无线循环分为三种:</span><br><span class="line"> <span class="number">1.</span></span><br><span class="line"> <span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="number">2.</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;学习&quot;</span>)；</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="number">3.</span></span><br><span class="line"> <span class="keyword">do</span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;学习&quot;</span>)；</span><br><span class="line"> &#125;<span class="keyword">while</span>(<span class="literal">true</span>);h</span><br></pre></td></tr></table></figure>

<p>2.continue：跳过本次循环，继续执行下次循环</p>
<p>3.break：结束整个循环</p>
<h2 id="10-数组"><a href="#10-数组" class="headerlink" title="10.数组"></a>10.数组</h2><h3 id="1-数组的介绍"><a href="#1-数组的介绍" class="headerlink" title="1.数组的介绍"></a>1.数组的介绍</h3><p>数组：是一种容器，可以用来存储同种数据类型的多个值</p>
<h3 id="2-数组的定义与静态初始化"><a href="#2-数组的定义与静态初始化" class="headerlink" title="2.数组的定义与静态初始化"></a>2.数组的定义与静态初始化</h3><p>初始化：就是在内存中，为数组容器开辟空间，并将数组存入整个容器的过程</p>
<p>完整格式：数字类型[] 数组名 &#x3D; new 数据类型[]{元素1，元素2，元素3……}；</p>
<p>范例：int[] array &#x3D; new int[]{11,22,33};</p>
<p>简化格式： 数据类型[] 数组名 &#x3D; {元素1，元素2，元素3……};</p>
<p>范例： int[] arrary &#x3D; {11,22,33};</p>
<p>数组地址：</p>
<p>数组的地址值:表示数组值在内存中的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩展</span></span><br><span class="line"><span class="comment">//解释一下地址值的格式含义 例如[D@776ec8df</span></span><br><span class="line"><span class="comment">//[ : 表示当前是一个数组</span></span><br><span class="line"><span class="comment">//D : 表示当前数组里面的元素都是double类型的</span></span><br><span class="line"><span class="comment">//776ec8df : 才是数组真正的地址值 （十六进制）</span></span><br><span class="line"><span class="comment">//平时外面习惯性的会把这个整体叫做数组的地址值</span></span><br></pre></td></tr></table></figure>

<h3 id="3-数组元素访问"><a href="#3-数组元素访问" class="headerlink" title="3.数组元素访问"></a>3.数组元素访问</h3><p>索引: 也叫做下标</p>
<p>索引的特点：从0开始，逐个+1增长，连续不间断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">也就是</span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> arr[<span class="number">0</span>]</span><br><span class="line">System.out.println(number)</span><br></pre></td></tr></table></figure>

<h3 id="4-数组遍历"><a href="#4-数组遍历" class="headerlink" title="4.数组遍历"></a>4.数组遍历</h3><p>在java当中，关于数组的一个长度属性，length  调用方式，数组名.length  System.out.println(arr.lenght)</p>
<p>在Java当中 自动的快速生成数组的遍历方式  idea提供的  数组名.fori</p>
<h3 id="5-数组动态初始化"><a href="#5-数组动态初始化" class="headerlink" title="5.数组动态初始化"></a>5.数组动态初始化</h3><p>动态初始化：初始化时只定数组长度，由系统为数组分配初始值</p>
<p>格式：数据类型[] 数组名 &#x3D; new 数据类型[数组长度];</p>
<p>范例：int[] arr &#x3D; new int[3];</p>
<p>数组默认初始值的规律</p>
<p>整数类型：默认初始值0</p>
<p>小数类型：默认初始值0.0</p>
<p>字符类型：默认初始值 ‘&#x2F;u0000’ 空格</p>
<p>布尔类型：默认初始值 false</p>
<p>引用数据类型：默认初始化值  NULL</p>
<p>数组动态初始化和静态初始化的区别</p>
<p>动态初始化：手动指定数组1长度，由系统给出默认初始值</p>
<pre><code>   只明确元素个数，不明确具体数值，推荐使用动态初始化
</code></pre>
<p>静态初始化：手动指定数组元素，系统会根据元素个数，计算出数组的长度</p>
<pre><code>   需求中已经明确了要操作的具体数据，直接静态初始化即可
</code></pre>
<h3 id="6-数组内存图"><a href="#6-数组内存图" class="headerlink" title="6.数组内存图"></a>6.数组内存图</h3><p>java内存分配</p>
<p>栈                         方法运行时使用的内存，比如main方法运行，进入方法栈中执行</p>
<p>堆                         存储对象或这数组，new来创建的，都存储在堆内存</p>
<p>方法区                 存储可以运行的class文件</p>
<p>本地方法栈         JVM在使用操作系统功能的时候使用，和我们开发无关</p>
<p>寄存器                  给CPU使用，和我们开发无关</p>
<p>总结：</p>
<p>1.只要是new出来的一定是在堆里面开辟一个小空间</p>
<p>2.如果new了多次，那么在堆里面有多个小空间，每个小空间中都有各自的数据</p>
<p>3.当两个数组指向同一个小空间时，其中一个数组对小空间中的值发生了改变，那么其他数组再次访问的时候都是修改之后的结果了</p>
<h3 id="7-数组常见问题"><a href="#7-数组常见问题" class="headerlink" title="7.数组常见问题"></a>7.数组常见问题</h3><p>访问越界异常</p>
<h2 id="11-方法"><a href="#11-方法" class="headerlink" title="11.方法"></a>11.方法</h2><h3 id="1-什么是方法"><a href="#1-什么是方法" class="headerlink" title="1.什么是方法"></a>1.什么是方法</h3><p>方法：是程序中的最小的执行单元</p>
<h3 id="2-方法的格式"><a href="#2-方法的格式" class="headerlink" title="2.方法的格式"></a>2.方法的格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式:</span><br><span class="line">pubilc <span class="keyword">static</span> <span class="keyword">void</span> 方法名()&#123;</span><br><span class="line">    方法体（就是打包起来的代码）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">范例:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">playgame</span><span class="params">()</span>&#123;</span><br><span class="line">    七个打印语句;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用:</span><br><span class="line">格式</span><br><span class="line">  方法名();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">调用:</span><br><span class="line">单个参数:<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名(参数)&#123;……&#125;</span><br><span class="line">多个参数:<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名(参数<span class="number">1</span>,参数<span class="number">2</span>,……)&#123;……&#125;</span><br></pre></td></tr></table></figure>

<p>形参和实参</p>
<p>形参：全称形式参数，是指方法定义中的参数</p>
<p>实参：全称实际参数，方法调用中的参数</p>
<h3 id="3-方法的重载"><a href="#3-方法的重载" class="headerlink" title="3.方法的重载"></a>3.方法的重载</h3><p>在同一类中，定义了多个同名的方法，这些同名的方法具有同种的功能</p>
<p>每个方法具有不同的参数类型或参数个数，这些同名的方法，就构成了重载关系</p>
<p>简单记：</p>
<p>同一类中，方法名相同，参数不同的方法，与返回值无关</p>
<p>参数不同：个数不同，类型不同，顺序不同</p>
<p>需求：使用方法重载的思想，设计比较两个整数是否相同的方法</p>
<p>需求：兼容全整数类型（byte，short,long）</p>
<h3 id="4-方法发内存"><a href="#4-方法发内存" class="headerlink" title="4.方法发内存"></a>4.方法发内存</h3><p>基本数据类型：数据值是存储在自己的空间中 </p>
<pre><code>   特点：赋值给其他变量，也是赋值的真实的值
</code></pre>
<p>引用数据类型：数据值是存储在其他空间中，自己空间中存储的是地址值</p>
<pre><code>    特点：赋值给其他变量，赋的地址值
</code></pre>
<h3 id="5-方法的值传递"><a href="#5-方法的值传递" class="headerlink" title="5.方法的值传递"></a>5.方法的值传递</h3><p>传输基本数据类型时：传递的时真实的数据，形参的改变，不影响实际参数的值</p>
<p>传输引用数据类型时：传参的时地址值，形参的改变，影响实际参数的值</p>
<h2 id="12面向对象"><a href="#12面向对象" class="headerlink" title="12面向对象"></a>12面向对象</h2><h3 id="1-设计对象并使用"><a href="#1-设计对象并使用" class="headerlink" title="1.设计对象并使用"></a>1.设计对象并使用</h3><p>1.类与对象</p>
<p>（1）类(设计图)：是对象共同特征的描述</p>
<p>（2）对象：是真是存在的具体东西</p>
<p>在java中，必须先设计类，才能获得对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名&#123;</span><br><span class="line">   <span class="number">1.</span>成员变量（代表属性，一般是名词）</span><br><span class="line">   <span class="number">2.</span>成员方法（代表行为，一般是动词）</span><br><span class="line">   <span class="number">3.</span>构造器（后面学习）</span><br><span class="line">   <span class="number">4.</span>代码块（后面学习）</span><br><span class="line">   <span class="number">5.</span>内部类（后面学习）</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如何得到对象</span><br><span class="line">类名 对象名 = mew 类名();</span><br><span class="line"><span class="type">Phone</span> <span class="variable">p</span> <span class="operator">=</span> newPhone();</span><br><span class="line"></span><br><span class="line">如何使用对象</span><br><span class="line">访问属性:对象名.成员变量</span><br><span class="line">访问行为:对象名.方法名(……)</span><br></pre></td></tr></table></figure>

<p>2.定义类的补充注意事项</p>
<p>（1）用来描述一类事物的类，专业叫做：javabean类，在javabean类中，是不写main方法的</p>
<p>（2）在以前，编写mian方法的类，叫做测试类 我们可以子啊测试类中创建javabean类的对象并进行            赋值调用</p>
<p>javabean类：</p>
<p>（1）类名首字母建议大写，需要见名知意，驼峰模式</p>
<p>（2）一个java文件中可以定义多个class类，且只能一个类是public修饰，而且public修饰的类名必须           成为代码文件名</p>
<pre><code>       实际开发中建议还是一个文件定义一个class类
</code></pre>
<p>（3）成员变量的完整定义格式是：修饰符 数据类型 变量名称 &#x3D; 初始化值； 一般无需指定初始化值             存在默认值 </p>
<h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h3><p>封装：对象代表什么，就得封装对应的数据，并提供数据对应的行为</p>
<p>private关键字</p>
<p>是一个权限修饰符</p>
<p>可以修饰成员（成员变量和成员方法）</p>
<p>被private修饰的成员只能在本类中才能访问，不让外界访问私有化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//针对于每一个私有化的成员变量，都要提供get和set方法</span></span><br><span class="line"><span class="comment">//set方法:给成员变量赋值</span></span><br><span class="line"><span class="comment">//get方法:对外提供成员变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">java_first</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">java_first</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//带全部参数的构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">java_first</span><span class="params">(String username,String password,String email,String gender,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get和set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">setGender</span><span class="params">(String gender)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-this关键字"><a href="#3-this关键字" class="headerlink" title="3.this关键字"></a>3.this关键字</h3><p>1.成员变量和局部变量核心</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>成员变量（实例&#x2F;类变量）</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>定义位置</td>
<td>类中，方法外</td>
<td>方法，构建器，代码块内</td>
</tr>
<tr>
<td>初始化</td>
<td>有默认值</td>
<td>必须显示初始化</td>
</tr>
<tr>
<td>作用域</td>
<td>整个类（首访问修饰符限制）</td>
<td>仅显声明的1代码块</td>
</tr>
<tr>
<td>内存位置</td>
<td>堆（实例）&#x2F; 方法区（类）</td>
<td>栈内存</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可使用</td>
<td>不可使用</td>
</tr>
</tbody></table>
<p>注意点：</p>
<p>若局部变量于与成员变量同名，局部变量会覆盖成员变量（就近原则），此时需要this（实例变量）或类名（类变量）区分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 局部变量（同名）</span></span><br><span class="line">        System.out.println(num); <span class="comment">// 20（局部变量）</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.num); <span class="comment">// 10（成员变量）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(若成员变量和全局变量没有用this关键字表示则变量则为就近原则)</p>
<p>总结：</p>
<p>this的作用：区分局部变量和成员变量</p>
<p>this的本质：所在方法调用者的地址值</p>
<h3 id="4-构造器"><a href="#4-构造器" class="headerlink" title="4.构造器"></a>4.构造器</h3><pre><code>1.构造方法概述
</code></pre>
<p>构造方法也叫作构造器，构造函数</p>
<p>作用：在创建对象的时候给成员变量进行赋值</p>
<pre><code> 2.构造方法的格式
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">   修饰符 类名(参数) &#123;</span><br><span class="line">            方法体;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<p>(1).方法名与类名相同，大小写也要一致</p>
<p>(2).没有返回值类型，连void都没有</p>
<p>(3).没有具体的返回值（不能由return带回结果数据）</p>
<p>执行实际：</p>
<p>(1).创建对象的时候由虚拟机调用，不能手动调用构建方法</p>
<p>(2).每创建一次对象，就会调用一次构建方法</p>
<pre><code>3.构造方法注意事项
</code></pre>
<p>(1).构造方法的定义</p>
<p>如果没有定义构造方法，系统将给出一个默认的无参数结构方法</p>
<p>如果定义了构造方法，系统将不再提供默认的构造方法</p>
<p>(2).构建方法的重载</p>
<p>带参构造方法，和无参数构造方法，两者方法名相同，但是参数不同，这叫做构造方法发重载</p>
<p>(3).推荐的使用方式</p>
<p>无论是否使用，都手动手写无参数构建造方法，和带全部参数的构造方法</p>
<h3 id="5-标准JavaBean"><a href="#5-标准JavaBean" class="headerlink" title="5.标准JavaBean"></a>5.标准JavaBean</h3><p>1.类名需要见名知意</p>
<p>2.成员变量使用private修饰</p>
<p>3.提供至少两个构造方法</p>
<p>（1）无参构造方法</p>
<p>（2）带全部参数的构造方法</p>
<p>4.成员方法</p>
<p>（1）提供每一个成员变量对应的setxxx()&#x2F;getxxx()</p>
<p>（2）如果还有其他行为，也需要写上</p>
<p><strong>快捷键：</strong></p>
<p><strong>alt + insert&#x2F;alt + Fn + insert</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">java_first</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">java_first</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//带全部参数的构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">java_first</span><span class="params">(String username,String password,String email,String gender,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get和set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">setGender</span><span class="params">(String gender)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-对象内存图"><a href="#6-对象内存图" class="headerlink" title="6.对象内存图"></a>6.对象内存图</h3><p>1.一个对象的内存图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>加载class文件，把student类的字节码文件加载到内存</span><br><span class="line"><span class="number">2.</span>申明局部变量，也就是对等号左边s来进行声明</span><br><span class="line"><span class="number">3.</span>在堆内存中开辟一个空间，也就是等号右边<span class="keyword">new</span>关键字，开辟一个小空间也就是对象</span><br><span class="line"><span class="number">4.</span>默认初始化</span><br><span class="line"><span class="number">5.</span>显示初始化</span><br><span class="line"><span class="number">6.</span>构造方法初始化</span><br><span class="line"><span class="number">7.</span>将堆内存中的地址值赋值给左边的局部变量</span><br></pre></td></tr></table></figure>

<p><img src="/images/java/java_1.png" alt="java_1.png"></p>
<p>全部执行完毕以后</p>
<p><img src="/images/java/java_2.png" alt="java_2.png"></p>
<p>2.多个对象的内存图</p>
<p>就是把一个对象重复了两次，和一个对象的内存图几乎一样只是重复两次</p>
<p>3.两个变量指向同一个对象内存图</p>
<p>和多个对象的内存图，一个对象的内存图几乎一样</p>
<p>4.this的内存原理</p>
<p><img src="/images/java/java_3.png" alt="java_3.png"></p>
<p>5.基本数据类型和引用数据类型的区别</p>
<p>基本数据类型：数据值是存储在自己的空间中</p>
<p>特点：赋值给其他变量，也是赋的真实的值</p>
<p>引用数据类型：数据值是存储在其他空间中，自己空间中存储的是地址值</p>
<p>特点：赋值给其他变量，赋的地址值</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>类中位置不变</td>
<td>类中，方法外</td>
<td>方法内，方法申明上</td>
</tr>
<tr>
<td>初始化值不同</td>
<td>有默认初始化值</td>
<td>没有，使用之前需要完成赋值</td>
</tr>
<tr>
<td>内存位置不同</td>
<td>堆内存</td>
<td>栈内存</td>
</tr>
<tr>
<td>生命周期不同</td>
<td>随着对象的建立而存在，随着对象的消失而消失</td>
<td>随着方法的调用而存在，随着方法的运行结束而消失</td>
</tr>
<tr>
<td>作用域</td>
<td>整个类中有效</td>
<td>当前方法中有效</td>
</tr>
</tbody></table>
<p>6.局部变量和成员变量的区别</p>
<p>成员变量：类中方法的变量</p>
<p>局部变量：方法中的变量</p>
<h2 id="13-API"><a href="#13-API" class="headerlink" title="13.API"></a>13.API</h2><h3 id="1-API介绍"><a href="#1-API介绍" class="headerlink" title="1.API介绍"></a>1.API介绍</h3><p>API(Application Programming Interface): 应用程序编程接口</p>
<p>简单理解：API就是别人已经写好的东西，我们不需要自己编写，直接使用即可</p>
<p>如我们之前用过的Scanner键盘录入的 Random随机数的</p>
<p>java API：指的就是JDK中提供的各自功能的java类</p>
<p>这些类将底层的实现封装了起来，我们不需要关心这些是如何实现的，只需要学习这些如何使用即可</p>
<h3 id="2-API帮助文档"><a href="#2-API帮助文档" class="headerlink" title="2.API帮助文档"></a>2.API帮助文档</h3><p>JDK 8中文在线手册(个人推荐)：<a target="_blank" rel="noopener" href="https://www.matools.com/api/java8">https://www.matools.com/api/java8</a> </p>
<p>JDK 11中文在线手册：<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/index.html">https://www.runoob.com/manual/jdk11api/index.html</a></p>
<h2 id="14-字符串"><a href="#14-字符串" class="headerlink" title="14.字符串"></a>14.字符串</h2><h3 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h3><p>1.String概述：java.lang.String类代表字符串，java程序中的所有字符串文字(例如“abc”)都为此类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line"><span class="type">String</span> <span class="variable">schoolName</span> <span class="operator">=</span> <span class="string">&quot;我是bluetea&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>String的注意点：字符串的内容是不会发生改变的，它的对象在创建后不能被改变</p>
<p>2.创建String对象的两种方式</p>
<p>(1).直接赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">naem</span> <span class="operator">=</span> <span class="string">&quot;我是bluetea&quot;</span></span><br></pre></td></tr></table></figure>

<p>(2)new</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>pubilc String( )</td>
<td>创建空白字符串，不含任何内容</td>
</tr>
<tr>
<td>public String(Strsing original)</td>
<td>根据传入的字符串，创建字符串对象</td>
</tr>
<tr>
<td>public String( char[] chs)</td>
<td>根据字符数组，创建字符串对象</td>
</tr>
<tr>
<td>public String(byte[] chs)</td>
<td>根据字节数组，创建字符串对象</td>
</tr>
</tbody></table>
<p>3.字符串之间的比较</p>
<p>(1)基本数据类型比较的是数据值</p>
<p>(2)引用数据类型比较的是地址值</p>
<p>(3)想要比较内容的办法</p>
<table>
<thead>
<tr>
<th>字符串比较</th>
<th>区别</th>
</tr>
</thead>
<tbody><tr>
<td>boolean equals方法(要比较的字符串)</td>
<td>不忽略大小写的比较</td>
</tr>
<tr>
<td>boolean equalslgnoreCase(要比较的字符串)</td>
<td>忽略大小写的比较</td>
</tr>
</tbody></table>
<p>完全一样的结果才是true，，否则为false</p>
<p>4.遍历字符串</p>
<p>需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串</p>
<p>public char charAt(int index): 根据索引返回字符</p>
<p>public int length(): 返回此字符串的长度</p>
<p>数组的长度：数组名.length</p>
<p>字符串的长度：字符串对象.length()</p>
<p>5.substring</p>
<p>substring(int beginIndex, int endIndex)</p>
<p>从 <code>beginIndex</code> 开始（包含该索引的字符），截取到 <code>endIndex</code> 结束（不包含该索引的字符），返回新的子字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arge)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">phonenumber</span> <span class="operator">=</span> <span class="string">&quot;12345678901&quot;</span>;</span><br><span class="line">        String <span class="type">phone</span> <span class="variable">start</span> <span class="operator">=</span> phonenumber.substring(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(phonenumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="2.StringBuilder"></a>2.StringBuilder</h3><p>1.StringBuilder概述：Stringbuilder可以看成是一个容器，创建之后里面的内容是可变的</p>
<p>作用：提高字符串的操作效率</p>
<p>2.StringBuilder常用方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public StringBuilder append(任意类型)</td>
<td>添加数据，并返回对象本身</td>
</tr>
<tr>
<td>public StringBuilder reverse()</td>
<td>反转容器中的内容</td>
</tr>
<tr>
<td>public int length()</td>
<td>返回长度（字符出现的个数）</td>
</tr>
<tr>
<td>public String toString()</td>
<td>通过toString()就可以实现吧StringBuilder转换成String</td>
</tr>
</tbody></table>
<h3 id="3-StingJoiner"><a href="#3-StingJoiner" class="headerlink" title="3.StingJoiner"></a>3.StingJoiner</h3><p>1.StringJoiner概述</p>
<p>StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的</p>
<p>作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用</p>
<p>JDK8出现</p>
<p>2.StringJoiner的构建方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public StringJoiner(间隔符号)</td>
<td>创建一个StringJoiner对象，指定拼接时的间隔符号</td>
</tr>
<tr>
<td>public StringJoiner(间隔符号，开始符号，结束符号)</td>
<td>创建一个StringJoine对象，指定拼接时的间隔符号开始符号,结束符号</td>
</tr>
</tbody></table>
<p>3.StringJoiner的成员方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public StringJoiner add(添加的内容)</td>
<td>添加数据，并返回对象本身</td>
</tr>
<tr>
<td>public int length()</td>
<td>返回长度（字符出现的个数）</td>
</tr>
<tr>
<td>public String toString()</td>
<td>返回一个字符串（该字符串就是拼接之后的结果）</td>
</tr>
</tbody></table>
<p>4.三个String的总结</p>
<p>String：表示字符串的类，定义了许多操作字符串的方法</p>
<p>StringBuilder：一个可变操作字符串的容器可以高效的拼接字符串，还可以将容器里面的内容反转</p>
<p>StringJoiner：JDK8出现的一个可变的操作字符串的容器，可以高效，方便的拼接字符串</p>
<h3 id="4-字符串原理"><a href="#4-字符串原理" class="headerlink" title="4.字符串原理"></a>4.字符串原理</h3><p>1.扩展底层原理1：字符串存储的内存原理</p>
<p>（1）直接赋值会复用字符串常量池中的</p>
<p>（2）new出来不会复用，而是开辟一个新的空间</p>
<p>2.扩展底层原理2：&#x3D;&#x3D;号比较的到底是什么</p>
<p>（1）基本数据类型比较数据值</p>
<p>（2）引用数据类型比较地址值</p>
<p>3.扩展底层原理3：字符串拼接的底层原理</p>
<p>如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串</p>
<p>如果有变量参与，每一行拼接的代码，都会在内存中创建的字符串，浪费内存</p>
<p>（1）字符串直接相加</p>
<p><img src="/images/java/java_4.png" alt="java_4.png"></p>
<p>(2)定义量相加</p>
<p><img src="/images/java/java_5.png" alt="java_5.png"></p>
<p>所以字符串拼接的时候有变量参与：在内存中创建了很多对象，浪费空间，时间也非常慢</p>
<p>结论：如果很多字符串变量拼接，不要直接+，在底层会创建多个对象，浪费时间，浪费性能</p>
<p>4.扩展底层原理4：StringBuilder提高效率原理图</p>
<p>（1）所以要拼接的内容都会往StringBuilder中放，不会创建很多无用的空间，节约内存</p>
<p>（2）字符串拼接的时候，如果有变量：</p>
<p>JDK8以前：系统底层会自动创建一个StringBuilder对象，然后再调用其append方法完成拼接</p>
<pre><code>                   拼接后，再调用其toString方法转换为String类型，而toString方法的底层是直接new了一个字符串对象
</code></pre>
<p>JDK8版本：系统会预估要字符串拼接之后的总大小，要把拼接的内容放在数组中，此时也是产生一个新的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">Sout(s1 == s3);</span><br><span class="line">的值为<span class="literal">false</span>，因为底层是直接<span class="keyword">new</span>了一个字符串对象</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">sout(s1 == s2);</span><br><span class="line">的值为<span class="literal">true</span>，因为再编译的时候，就会将 <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>拼接为<span class="string">&quot;abc&quot;</span>。记录了<span class="string">&quot;abc&quot;</span>串池中的</span><br><span class="line">地址值,而<span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>复用了<span class="string">&quot;abc&quot;</span>串池中的字符串所以s1 == s2时就是自己比较自己</span><br></pre></td></tr></table></figure>

<p>5.扩展底层原理5：StringBuilder原码分析</p>
<p>默认创建一个长度为16的字节数组</p>
<p>添加的内容长度小于16，直接存放</p>
<p>添加的内容大于16会扩容（原来的容量*2+2）</p>
<p>如果扩容之后还不够，以实际长度为准</p>
<h2 id="15-集合"><a href="#15-集合" class="headerlink" title="15.集合"></a>15.集合</h2><h3 id="1-为什么要有集合"><a href="#1-为什么要有集合" class="headerlink" title="1.为什么要有集合"></a>1.为什么要有集合</h3><p>集合是无法直接存储基本数据类型</p>
<h3 id="2-集合"><a href="#2-集合" class="headerlink" title="2.集合"></a>2.集合</h3><p>(1).ArrayList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()</span><br><span class="line"><span class="comment">//创建了一个名为list存储数据的类型为String类型的集合</span></span><br></pre></td></tr></table></figure>

<p>（2）ArrayList成员方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(E e)</td>
<td>添加元素，返回值表示是否添加成功</td>
</tr>
<tr>
<td>boolean remove(E e)</td>
<td>删除指定元素，返回值表示是否删除成功</td>
</tr>
<tr>
<td>E remove(int inddex)</td>
<td>删除指定索引的元素，返回被删除元素</td>
</tr>
<tr>
<td>E set(int index,E e)</td>
<td>修改指定索引下的元素，返回原来的元素</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>获取指定索引的元素</td>
</tr>
<tr>
<td>int size()</td>
<td>集合的长度，也就是集合中元素的个数</td>
</tr>
</tbody></table>
<p>总结：增删改查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> list.remove(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">sout(result1);</span><br><span class="line"><span class="comment">//修改元素</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> list.set(<span class="number">1</span>,<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">sout(result);</span><br><span class="line"><span class="comment">//元素的查询</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">sout(s)</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    sout(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">[ddd,bbb,ccc]</span><br><span class="line">ddd</span><br><span class="line">ddd</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>

<p>3.基本数据类型对应的包装类</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
</tbody></table>
<p>用法：</p>
<p>ArrayList&lt;包装类&gt;这是正确的</p>
<p>ArrayList&lt;基本数据类型&gt;这是错误的</p>
<h2 id="16-面向对象升级"><a href="#16-面向对象升级" class="headerlink" title="16.面向对象升级"></a>16.面向对象升级</h2><h3 id="1-static"><a href="#1-static" class="headerlink" title="1.static"></a>1.static</h3><p>1.static表示静态，是java中的一个修饰符，可以修饰成员方法，成员变量</p>
<table>
<thead>
<tr>
<th>被static修饰的成员变量，叫做静态变量</th>
<th>被static修饰的成员方法，叫做静态方法</th>
</tr>
</thead>
<tbody><tr>
<td>特点：被该类所有对象共享                                                                       不属于对象，属于类                                                                      随着类的加载而加载，优先于对象存在</td>
<td>特点：多用在测试类和工具类中                                                                    Javabean类中很少会用</td>
</tr>
<tr>
<td>调用方法：类名调用（推荐）                                                                          对象名调用</td>
<td>调用方法：类名调用（推荐）                                                                                  对象名调用</td>
</tr>
</tbody></table>
<p>2.工具类  </p>
<p>javabean类：用来描述一类事物的类。比如，Student，Teacher，Dog，Cat等</p>
<p>测试类：用来检查其他类是否书写正确，带有main方法的类，是程序的入口</p>
<p>工具类：不是用来描述一类事物的，而是帮我们做一些事情的类</p>
<p>他们帮助我们做一些事情的，但是不描述任何事物的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pubilc <span class="keyword">class</span> <span class="title class_">ArraryUtil</span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">ArraryUtil</span><span class="params">()</span>&#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">printArr</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(i == arr.length - <span class="number">1</span>)&#123;</span><br><span class="line">                  sb.append(arr[i]);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  sb.append(arr[i].append(<span class="string">&quot;,&quot;</span>));               </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">      &#125;   </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getAverage</span><span class="params">(<span class="type">double</span>[] arr)</span>&#123;</span><br><span class="line">          <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">               sum = sum + arr[i];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> sum / arr.length;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样就可以在外面使用你自定义的工具来使用</span></span><br></pre></td></tr></table></figure>

<p>3.static的注意事项</p>
<p>什么是静态：静态就是随着类的加载而加载</p>
<p>什么是非静态：跟对象有关</p>
<p>静态方法只能访问静态变量和静态方法</p>
<p>非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法</p>
<p>静态方法中是没有this关键字</p>
<p>总结：</p>
<p>静态方法中，只能访问静态</p>
<p>非静态方法可以访问所以</p>
<p>静态方法中没有this关键字</p>
<h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h3><p>1.继承的介绍</p>
<p>java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起继承关系</p>
<p>public class Student extend person{}</p>
<p>Student称为子类（派生类），person称为父类（基类或超类）</p>
<p>使用继承的好处：</p>
<p>可以把多个子类中重复的代码抽取到父亲中了，提高代码的复用性</p>
<p>子类可以在父亲的基础上，增加其他的功能，使子类更强大</p>
<p>什么时候用继承：</p>
<p>当类与类之间，存在相同(共性)的内容，并满足子类使父亲中的一种，就可以考虑使用继承，来优化代码</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>public 不能</th>
<th>private 不能</th>
</tr>
</thead>
<tbody><tr>
<td>成员变量</td>
<td>public 能</td>
<td>private 能</td>
</tr>
<tr>
<td>成员方法</td>
<td>public 能</td>
<td>private 不能</td>
</tr>
</tbody></table>
<p>2.继承的特点</p>
<p>java只支持单线程，不支持多线程，单支持多层继承</p>
<p>3.继承中：成员变量的访问特点</p>
<p>就近原则，谁离我近，我就用谁</p>
<p>（先在局部位置找，奔雷成员位置找，父类成员位置找，逐级往上）</p>
<p>4.super</p>
<p>super和this比较相似可以这么认为this就是指向子类，那么super就是指向父类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(name);  <span class="comment">//从局部位置往上找</span></span><br><span class="line">System.out.println(<span class="built_in">this</span>.name);   <span class="comment">//从本类成员位置开始往上找</span></span><br><span class="line">System.out.println(<span class="built_in">super</span>.name);  <span class="comment">//从父类成员位置开始往上找</span></span><br></pre></td></tr></table></figure>

<p>5.方法的重写</p>
<p>   当父类的方法不能满足子类现在的需求时，需要进行方法重写</p>
<p>书写格式</p>
<pre><code>在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法时重写的方法
</code></pre>
<p> @Override重点注释</p>
<pre><code>1. @override是放在重写后的方法上，校验子类重写时语法是否正确

2.加上注解后如果有红色波浪线，表示语法错误

3.建议重写方法都加@Override注解，代码安全，优雅！
</code></pre>
<p>6.方法重写注意事项和需求</p>
<pre><code>1.重写方法的名称，形参列表必须与父类的一致

2.子类重写父类方法时，访问权限子类必须大于等于父类 （暂时了解：空者不写&lt;protected&lt;public）

3.子类重写父类方法时，返回值类型子类必须小于等于父类

4.建议：重写的方法尽量和父类保持一致

5.只有被添加到虚方法表中的方法才能重写
</code></pre>
<p>7.继承中：构造方法的访问特点</p>
<p>（1）访问特点</p>
<p>父类中的构造方法不会被子类继承</p>
<p>子类中所以的构造方法默认先访问父亲中的无参构造，再执行自己</p>
<p>（2）为什么？</p>
<p>子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据</p>
<p>子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化</p>
<p>（3）怎么调用父类构造方法的？</p>
<p>子类构造方法的第一行语句默认都是：super()，不写也存在，且必须在第一行</p>
<p>如果想调用父类有参构造，必须手动写super进行调用</p>
<h3 id="3-包，final，权限修饰符，代码块"><a href="#3-包，final，权限修饰符，代码块" class="headerlink" title="3.包，final，权限修饰符，代码块"></a>3.包，final，权限修饰符，代码块</h3><p>1.什么是包</p>
<p>包就是文件夹。用来管理各种不同功能的java类，方便后期代码维护</p>
<p>包的本质：包的本质上是目录结构的映射：一个包对应文件系统中的一个目录（例如，com.exampke.demo 对应 com&#x2F;example&#x2F;demo 文件夹），类(.class)会被编译到对应目录下</p>
<p>包的声明与使用</p>
<p>（1）声明包</p>
<p>每个类的第一行(注释除外)需要package语句声明所属包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service; <span class="comment">//包名全部小写，多段用 . 分隔（遵循域名反转规则，如公司域名 example.com 对应 com.example）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>若未声明package，类属于默认包(无包名)，不建议在实际开发中使用(易冲突且无法被其他包访问)</p>
<p>（2）使用其他包的类</p>
<p>有三种方式访问其他包的类</p>
<p>[1] 权限定名：直接使用完整包名+类名，例如</p>
<p>java.util.Arrarylist list &#x3D; new</p>
<p>java.util.ArrarList();</p>
<p>[2] import语句：在类顶部导入目标类，简化后续使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 导入单个类</span></span><br><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">// 导入 java.util 包下所有类（不推荐，可能引发冲突）</span></span><br></pre></td></tr></table></figure>

<p>[3] 静态导入：导入类的静态成员（方式&#x2F;变量），可直接使用成员名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI; <span class="comment">// 导入 Math 类的静态变量 PI</span></span><br><span class="line">System.out.println(PI); <span class="comment">// 直接使用 PI，无需 Math. 前缀</span></span><br></pre></td></tr></table></figure>

<p>包名的规则：公司域名反写+包的作用，需要全部英文小写，见名知意 如:com.itheima.domain</p>
<p>2.final</p>
<p>final修饰方法：表明该方法时最终方法，不能被重写</p>
<p>final修饰类：表明该类时最终类，不能被继承</p>
<p>final修饰变量：叫做常量，只能被赋值一次</p>
<p>常量：</p>
<p>实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性</p>
<p>常量的命名规范：</p>
<p>单个单词：全部大写</p>
<p>多个单词：全部大写，单词之间用下划线隔开</p>
<p>细节：</p>
<p>final修饰的变量是基本类型：那么变量存储的数据值不能发生改变</p>
<p>final修饰的变量是引用类型：那么变量存储的地址值不能发生改变，对象内部的可以改变</p>
<p>3.权限修饰符的分类</p>
<p>有四种作用范围由小到大（private&lt;空着不写&lt;protected&lt;public）</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类中</th>
<th>同一个包中其他类</th>
<th>不同包下的子类</th>
<th>不同包下的无关类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>对</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>空着不写</td>
<td>对</td>
<td>对</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>对</td>
<td>对</td>
<td>对</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>对</td>
<td>对</td>
<td>对</td>
<td>对</td>
</tr>
</tbody></table>
<p>权限修饰符的使用规则：</p>
<p>实际开发中，一般只用private和public</p>
<p>成员变量私有</p>
<p>方法公开</p>
<p>特例：如果方法中的代码是抽取其他方法中供性代码，这个方法一般也私有</p>
<p>4.代码块</p>
<p>（1）局部代码块</p>
<p>位置：定义在方法，循环，条件语句等内部</p>
<p>作用：限制变量的作用域（局部变量仅在代码块内有效），避免冲突</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通代码块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            System.out.println(a); <span class="comment">// 10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(a); // 报错：a未定义（超出作用域）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）构造代码块</p>
<p>位置：直接定义在类中，方法之外</p>
<p>特点：</p>
<p>每次创建对象时执行，且执行顺序在构造方法之前</p>
<p>若由多个构造代码块，按定义顺序依次执行</p>
<p>作用：提取多个构造方法中的公共逻辑，简化代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行有参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// 执行构造代码块</span></span><br><span class="line">        <span class="comment">// 执行无参构造</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// 执行构造代码块</span></span><br><span class="line">        <span class="comment">// 执行有参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）静态代码块</p>
<p>位置：直接定义在类中，用static修饰</p>
<p>特点：</p>
<p>随着类的加载而加载</p>
<p>属于类级别的代码块，仅在类加载时执行一次（无论创建多少对象，只执行一次）</p>
<p>若由多个静态代码块，按定义顺序依次进行</p>
<p>作用：初始化静态变量，加载资源（如配置文件），执行类级别的预处理操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        version = <span class="string">&quot;1.0.0&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行，初始化version&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tool</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建Tool对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Tool</span>(); <span class="comment">// 类加载时执行静态代码块，然后执行构造方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Tool</span>(); <span class="comment">// 仅执行构造方法（静态代码块已执行过）</span></span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// 静态代码块执行，初始化version</span></span><br><span class="line">        <span class="comment">// 创建Tool对象</span></span><br><span class="line">        <span class="comment">// 创建Tool对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）同步代码块</p>
<p>位置：通常在方法内部</p>
<p>特点：用synchronized修饰,用于多线程环境下保证代码的原子性（同一时间仅一个线程执行）</p>
<p>语法：synchronized(锁对象) { … }</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 锁对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）代码块执行顺序总结</p>
<p>当类初始化并创建对象时，执行顺序为：</p>
<p>静态代码块(类加载时) → 构造代码块(对象创建时) → 构造方法(对象创建时)</p>
<h3 id="4-抽象类"><a href="#4-抽象类" class="headerlink" title="4.抽象类"></a>4.抽象类</h3><p>1.抽象方法</p>
<p>（1）抽象方法：将共性的行为(方法)抽取到父类之后由于每一个子类执行的内容是不一样，所以，在父类中不能确定具体的方法体该方法就是可以定义抽象方法</p>
<p>（2）抽象类：如果一个类中存在抽象方法，那么该类就必须声明为抽象类</p>
<p>2.抽象类和抽象方法发定义格式</p>
<p>（1）抽象方法的定义格式：</p>
<p>public abstract 返回值类型 方法名(参数列表)；</p>
<p>（2）抽象类的定义格式：</p>
<p>public abstract class 类名 {}</p>
<p>3.抽象类和抽象方法的注意事项</p>
<p>抽象类不能实例化</p>
<p>抽象类中不一定有抽象方法，有抽象方法的类一定时抽象类</p>
<p>可以有构造方法</p>
<p>抽象类的子类：要么重写抽象类中的所有抽象方法，要么是抽象类</p>
<h3 id="5-接口"><a href="#5-接口" class="headerlink" title="5.接口"></a>5.接口</h3><p>1.接口的定义和使用</p>
<p>（1）接口用关键字interface来定义</p>
<p>public interface 接口名 {}</p>
<p>（2）接口不能实例化</p>
<p>（3）接口和类之间是实现关系，通过implements关键字表示</p>
<p>pubilc class 类名 implements 接口名 {}</p>
<p>（4）接口的子类（实现类）</p>
<p>要么重写接口中的所有抽象方法</p>
<p>要么是抽象类</p>
<p>注意1：接口和类的实现关系，可以单实现，也可以多实现</p>
<p>public class 类名 implements 接口名1，接口名2 {}</p>
<p>注意2：实现类还可以在继承一个类的同时实现多个接口</p>
<p>public class 类名 extend 父类 implement 接口名1 ，接口名2 {}</p>
<p>2.接口中成员的特点</p>
<p>（1）成员变量： 只能是常量</p>
<p>默认修饰符：public static final</p>
<p>（2）构造方法：没有</p>
<p>（3）成员方法：只能是抽象方法</p>
<p>默认修饰符：public abstract</p>
<p>3.接口和类之间的关系</p>
<p>（1）类和类的关系</p>
<p>继承关系，只能单继承，不能多继承，但是可以多层继承</p>
<p>（2）类和接口的关系</p>
<p>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p>
<p>（3）接口和接口的关系</p>
<p>继承关系，可以单继承，也可以多继承</p>
<p>4.接口中默认方法的定义格式</p>
<p>格式： public default 返回值类型 方法名(参数列表){  }</p>
<p>接口中默认方法的注意事项：</p>
<p>（1）默认方法不是抽象方法，所以不强制被重写，但是如果被重写，重写的时候去掉default关键字</p>
<p>（2）public可以省略，default不能省略</p>
<p>（3）如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写</p>
<p>5.接口中的静态方法的定义</p>
<p>接口中静态方法的定义格式：</p>
<p>格式：piblic static 返回值类型 方法名(参数列表){  }</p>
<p>范例：public static void show() {  }</p>
<p>接口中静态方法的注意事项：<br>（1）静态方法只能通过接口名调用，不能通过实现类名或者对象名调用</p>
<p>（2）public可以省略，static不能省略</p>
<p>6.接口中私有方法的定义</p>
<p>接口中私有方法的定义格式</p>
<p>（1）格式1：private 返回值类型 方法名(参数列表) {  }</p>
<p>范例1：private void show() {  }</p>
<p>（2）格式2：private static 返回值类型 方法名(参数列表) {  }</p>
<p>范例2：private static void method() {  }</p>
<p>7.接口的总结</p>
<p>(1)接口代表规则，是行为的抽象。想要让哪个类拥有一个行为，就让这个类实现对应的接口就可以</p>
<p>(2)当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方法称之为接口多态</p>
<p>适配器设计模式：</p>
<p>（1）当一个接口抽象方法过多，但是我只要使用其中一部分的时候，就可以适配器设计模式</p>
<p>（2）书写步骤：</p>
<p>编写中间类xxxAdapter，实现对应的接口</p>
<p>对接口中的抽象方法进行空实现</p>
<p>让真正的实现类继承中间类，并重写需要用的方法</p>
<p>为了避免其他类创建适配器类的对象，中间的适配器类用abstract进行修饰</p>
<h3 id="6-多态"><a href="#6-多态" class="headerlink" title="6.多态"></a>6.多态</h3><p>1.什么是多态</p>
<p>同类型的对象，表现出的不同形态</p>
<p>2.使用其他类的规则</p>
<p>（1）使用同一个包中的类时，不需要导包</p>
<p>（2）使用java.lang包中的类时，不需要导包</p>
<p>（3）其他情况都需要导包</p>
<p>（4）如果同时使用两个包中的同类名，需要用全类名</p>
<p>2.多态的表现形式</p>
<p>父类类型 对象名称 &#x3D; 子类对象；</p>
<p>3.多态的前提</p>
<p>有继承关系</p>
<p>有父类引用指向子类对象  Fu f &#x3D; new Zi();</p>
<p>有方法重写</p>
<p>4.多态调用成员的特点</p>
<p>（1）变量调用：编译看左边，运行也看左边</p>
<p>（2）方法调用：编译看左边，运行看右边</p>
<p>5.多态的优势</p>
<p>（1）在多态形式下，右边对象可以实现解耦合，便于扩展和维护</p>
<p>（2）定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利</p>
<p>6.多态的弊端</p>
<p>（1）不能使用子类的特有功能</p>
<p>如果想要引用子类的特有功能要进行强制类型转换</p>
<p>（2）强制类型转换能解决什么问题</p>
<p>[1]可以转换成真正的子类类型，从而调用子类独有功能</p>
<p>[2]转换类型与真实对象类型不一致会报错</p>
<p>[3]转换的时候用instanceof关键字进行判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先判断a是否Dog类型，如果是，则强转成Dog类型，转换之后变量名为d</span></span><br><span class="line"><span class="comment">//如果不是，则不强转，结果直接是false</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog d)&#123;</span><br><span class="line"> d.lookHome();</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat c)&#123;</span><br><span class="line"> c.catchMouse();</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;没有这个类型，无法转换&quot;</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-内部类"><a href="#7-内部类" class="headerlink" title="7.内部类"></a>7.内部类</h3><p>类的五大成员：</p>
<p>属性，方法，构造方法，代码块，内部类</p>
<p>内部类：在一个类的里面，在定义一个类</p>
<p>内部类的访问特点：</p>
<p>[1]内部类可以直接访问外部类的成员，包括私有化</p>
<p>[2]外部类要访问内部类的成员，必须创建对象</p>
<p>（1）成员内部类</p>
<p>[1]写在成员位置的，属于外部类的成员</p>
<p>成员内部类可以被一些修饰符所修饰 ，比如private，默认，protected，public，static等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span>&#123;  <span class="comment">//外部类</span></span><br><span class="line">    String carname;</span><br><span class="line">    <span class="type">int</span> carage;</span><br><span class="line">    <span class="type">int</span> carcolor;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span>&#123;  <span class="comment">//成员内部类</span></span><br><span class="line">    String enginename;</span><br><span class="line">    <span class="type">int</span> engineage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[2]获取成员内部类对象</p>
<p>方法一： 在外部类中编写方法，对外提供内部类的对象</p>
<p>方法二： 直接创建格式：外部类名.内部类名 对象名 &#x3D; 外部类对象.内部类对象；</p>
<p>范例： Outer.Inner oi &#x3D; new Outer( ).new Ineer( );</p>
<p>[3]内容的打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">            System.out.println(outer.<span class="built_in">this</span>.a);<span class="comment">//10</span></span><br><span class="line">            System.out <span class="title function_">println</span><span class="params">(<span class="built_in">this</span>.a)</span>;<span class="comment">//20</span></span><br><span class="line">            System.out.println(a);<span class="comment">//30</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        outer.<span class="type">inner</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">outer</span>().<span class="keyword">new</span> <span class="title class_">inner</span>();</span><br><span class="line">        oi.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）静态内部类</p>
<p>静态内部类只能访问类中的静态变量和静态方法，如果想要访问非静态的需要创建对象</p>
<p>创建静态内部类对象的格式：外部类名.内部类名 对象名 &#x3D; new 外部类名.内部类名();</p>
<p>调用非静态方法的格式：先创建对象，用对象调用</p>
<p>调用静态方法的格式：外部类名.内部类名.方法名();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">outer</span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">inner</span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">()</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;非静态发方法被调用了&quot;</span>)；</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;静态的方法被调用了&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        outer.<span class="type">inner</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">outer</span>().<span class="keyword">new</span> <span class="title class_">inner</span>();</span><br><span class="line">        oi.show1();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//静态方法</span></span><br><span class="line">        outer.inner.show2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）局部内部类</p>
<p>1.将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量</p>
<p>2.外界是无法直接使用，需要在方法内创建对象并使用</p>
<p>3.该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p>
<p>（4）匿名内部类</p>
<p>匿名内部类本质上就是隐藏了名字的内部</p>
<p>匿名内部类的特点</p>
<p>1.没有类名：直接通过父类或接口来创建实例，无需定义类名</p>
<p>2.只能使用一次：匿名内部类的实例是一次性的，无法重复使用</p>
<p>3.必须继承一个类或者实现一个接口：不能独立存在，必须依托于某个父类或接口</p>
<p>4.语法特殊：创建对象的同时定义类的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于接口的匿名内部类</span></span><br><span class="line">接口名 对象名 = <span class="keyword">new</span> 接口名() &#123;</span><br><span class="line">    <span class="comment">// 实现接口中的抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 方法名() &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于类的匿名内部类</span></span><br><span class="line">父类名 对象名 = <span class="keyword">new</span> 父类名() &#123;</span><br><span class="line">    <span class="comment">// 可以重写父类的方法，或添加新方法（但新方法无法通过父类引用调用）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 父类方法() &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p>匿名内部类常用于简化回调的实现(如事件监听，线程创建等)，避免单独定义一个类的繁琐</p>
<p><strong>示例一：基于接口的匿名内部类</strong></p>
<p>假设参在一个接口Greeting，需要创建其实实例并实现方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建匿名内部类，实现 Greeting 接口</span></span><br><span class="line">        <span class="type">Greeting</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, 匿名内部类！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        greeting.sayHello(); <span class="comment">// 输出：Hello, 匿名内部类！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有单独定义实现类，而事在创建Greeting实例时直接实现sayHello方法</p>
<p><strong>示例二：基于类的匿名内部类</strong></p>
<p>继承一个类并重写其方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建匿名内部类，继承 Animal 并重写 shout 方法</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猫叫：喵喵~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        cat.shout(); <span class="comment">// 输出：猫叫：喵喵~</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例三：线程中的匿名内部类</p>
<p>创建线程时，匿名内部类可简化Runnable接口的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 匿名内部类实现 Runnable 接口</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程执行中...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start(); <span class="comment">// 输出：线程执行中...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<p>1.访问外部变量：匿名内部类访问的外部局部变量时必须是final或事实上的final(即变量值不会被修改)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 必须是 final 或不可修改</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(num); <span class="comment">// 可以访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.不能有构建方法：匿名内部类没有类名，因此无法定义构造方法，但可以通过实例初始化块初始化</p>
<p>3.新方法的访问限制：如果匿名内部类添加了父类 &#x2F; 接口中没有的新方法，无法通过父类 &#x2F; 接口的引用调用（需强制类型转换，但通常无意义）</p>
<h2 id="快捷键小技巧"><a href="#快捷键小技巧" class="headerlink" title="快捷键小技巧"></a>快捷键小技巧</h2><p>1.ctrl + alt + insert 可以快速建立空参set和get方法等</p>
<p>2.ctrl + alt + m  可以将你选中的区域快速抽取成一个方法</p>
<h3 id="小众知识点"><a href="#小众知识点" class="headerlink" title="小众知识点"></a>小众知识点</h3><p>1.原码，反码，补码</p>
<p>原码：十进制数据的二进制表现形式，最左边是符号位，0为正，1为负</p>
<p>反码：整数的补码是其本身，负数的反码是符号位保持不变，其余位取反</p>
<p>补码：正数的补码是其本身，负数的补码是在其反码的基础上+1</p>
<p>详细原理在我的c语言解析里有解释</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://17bluetea.github.io">bluetea</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://17bluetea.github.io/2025/12/20/java_study/">https://17bluetea.github.io/2025/12/20/java_study/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://17bluetea.github.io" target="_blank">Welcome to my blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post-share"><div class="social-share" data-image="/images/qita/java.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/10/10/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="c语言基础到精通"><img class="cover" src="/images/qita/c.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">c语言基础到精通</div></div><div class="info-2"><div class="info-item-1">c语言的一些系统性的知识</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bluetea</div><div class="author-info-description">android and Internet security</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/17bluetea" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:632326649@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java-study"><span class="toc-number">1.</span> <span class="toc-text">java_study</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java-%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.</span> <span class="toc-text">1. Java 中的注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.</span> <span class="toc-text">2. 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">3. 字面量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">4. 变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">5. 数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.6.</span> <span class="toc-text">6. 标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%EF%BC%88Scanner%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">7. 键盘录入（Scanner）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.</span> <span class="toc-text">8. 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.2.</span> <span class="toc-text">（2）自增自减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.3.</span> <span class="toc-text">（3）赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%EF%BC%88%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.8.4.</span> <span class="toc-text">（4）（关系运算符&#x2F;比较运算符）的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.5.</span> <span class="toc-text">（5）逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.6.</span> <span class="toc-text">（6）三元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.8.7.</span> <span class="toc-text">（7）运算符的优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.9.</span> <span class="toc-text">9.流程控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.1.</span> <span class="toc-text">（1）顺序结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.2.</span> <span class="toc-text">（2）分支结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.3.</span> <span class="toc-text">（3）循环结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E9%AB%98%E7%BA%A7%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.9.4.</span> <span class="toc-text">（4）高级循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%95%B0%E7%BB%84"><span class="toc-number">1.10.</span> <span class="toc-text">10.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.10.1.</span> <span class="toc-text">1.数组的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.10.2.</span> <span class="toc-text">2.数组的定义与静态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-number">1.10.3.</span> <span class="toc-text">3.数组元素访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.10.4.</span> <span class="toc-text">4.数组遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.10.5.</span> <span class="toc-text">5.数组动态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">1.10.6.</span> <span class="toc-text">6.数组内存图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.7.</span> <span class="toc-text">7.数组常见问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">11.方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.1.</span> <span class="toc-text">1.什么是方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.11.2.</span> <span class="toc-text">2.方法的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.11.3.</span> <span class="toc-text">3.方法的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E5%8F%91%E5%86%85%E5%AD%98"><span class="toc-number">1.11.4.</span> <span class="toc-text">4.方法发内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">1.11.5.</span> <span class="toc-text">5.方法的值传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.</span> <span class="toc-text">12面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E5%AF%B9%E8%B1%A1%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">1.12.1.</span> <span class="toc-text">1.设计对象并使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B0%81%E8%A3%85"><span class="toc-number">1.12.2.</span> <span class="toc-text">2.封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.12.3.</span> <span class="toc-text">3.this关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.12.4.</span> <span class="toc-text">4.构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A0%87%E5%87%86JavaBean"><span class="toc-number">1.12.5.</span> <span class="toc-text">5.标准JavaBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">1.12.6.</span> <span class="toc-text">6.对象内存图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-API"><span class="toc-number">1.13.</span> <span class="toc-text">13.API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-API%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.13.1.</span> <span class="toc-text">1.API介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-API%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3"><span class="toc-number">1.13.2.</span> <span class="toc-text">2.API帮助文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.14.</span> <span class="toc-text">14.字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-String"><span class="toc-number">1.14.1.</span> <span class="toc-text">1.String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-StringBuilder"><span class="toc-number">1.14.2.</span> <span class="toc-text">2.StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-StingJoiner"><span class="toc-number">1.14.3.</span> <span class="toc-text">3.StingJoiner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%9F%E7%90%86"><span class="toc-number">1.14.4.</span> <span class="toc-text">4.字符串原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E9%9B%86%E5%90%88"><span class="toc-number">1.15.</span> <span class="toc-text">15.集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E9%9B%86%E5%90%88"><span class="toc-number">1.15.1.</span> <span class="toc-text">1.为什么要有集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9B%86%E5%90%88"><span class="toc-number">1.15.2.</span> <span class="toc-text">2.集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8D%87%E7%BA%A7"><span class="toc-number">1.16.</span> <span class="toc-text">16.面向对象升级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-static"><span class="toc-number">1.16.1.</span> <span class="toc-text">1.static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.16.2.</span> <span class="toc-text">2.继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8C%85%EF%BC%8Cfinal%EF%BC%8C%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.16.3.</span> <span class="toc-text">3.包，final，权限修饰符，代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.16.4.</span> <span class="toc-text">4.抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.16.5.</span> <span class="toc-text">5.接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A4%9A%E6%80%81"><span class="toc-number">1.16.6.</span> <span class="toc-text">6.多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.16.7.</span> <span class="toc-text">7.内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">1.17.</span> <span class="toc-text">快捷键小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E4%BC%97%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.17.1.</span> <span class="toc-text">小众知识点</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/20/java_study/" title="java基础到精通"><img src="/images/qita/java.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java基础到精通"/></a><div class="content"><a class="title" href="/2025/12/20/java_study/" title="java基础到精通">java基础到精通</a><time datetime="2025-12-20T00:00:00.000Z" title="发表于 2025-12-20 08:00:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/10/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="c语言基础到精通"><img src="/images/qita/c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c语言基础到精通"/></a><div class="content"><a class="title" href="/2025/10/10/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="c语言基础到精通">c语言基础到精通</a><time datetime="2025-10-10T12:00:00.000Z" title="发表于 2025-10-10 20:00:00">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/home/first.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By bluetea</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>